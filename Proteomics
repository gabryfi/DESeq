############################################
############################################
############################################
#### Differential Analysis Proteomics (without & with covariates)
############################################

# NO covariate


library(janitor)
library(dplyr)
library(tidyr)
library(ggplot2)
library(limma)
library(reshape2)
library(readr)
library(magrittr)
library(tibble)

###########################################
### Import e preparazione dati
###########################################

# Import dati
endoicd <- read.delim("istance_3.csv", sep = ",", header = TRUE)                      #### proteins (endoicd)
phenoicd <- read.delim("gender_pain_nocancer_all.csv", sep = ",", header = TRUE)      #### metadata (phenoicd) 

# Pulizia nomi colonne
endoicd <- clean_names(endoicd)
phenoicd <- clean_names(phenoicd)

# Metadata e espressione
metadata <- phenoicd
expr <- endoicd

# Associare ID come rownames
rownames(metadata) <- metadata$participant_id
metadata$participant_id <- NULL

rownames(expr) <- expr$participant_id
expr$participant_id <- NULL

# Tenere solo i pazienti comuni
common_ids <- intersect(rownames(metadata), rownames(expr))
metadata <- metadata[common_ids, ]
expr <- expr[common_ids, ]

###########################################
### Quality control: distribuzione per campione
###########################################

df_t <- t(expr)
df_long <- melt(df_t, varnames = c("Protein", "Sample"), value.name = "Expression")
df_long$Sample <- factor(df_long$Sample)

ggplot(df_long, aes(x = Sample, y = Expression)) +
  geom_boxplot(outlier.size = 0.5) +
  theme_bw(base_size = 14) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 6)) +
  labs(title = "Distribution of samples (per sample boxplot)",
       x = "Sample",
       y = "Expression")

###########################################
### Normalizzazione e boxplot proteine
###########################################

df_scaled <- as.data.frame(scale(expr, center = TRUE, scale = TRUE))

png("QC_first_200_endo.png", width = 1080, height = 1080)
boxplot(df_scaled[, 1:min(200, ncol(df_scaled))],
        las = 2,
        main = "Distribution of the first 200 proteins (normalized)",
        ylab = "Z-scored Expression",
        outline = FALSE,
        cex.axis = 0.5)
dev.off()

###########################################
### PCA
###########################################

# Rimozione proteine con almeno 10% di NA
missing_perc <- colSums(is.na(expr)) / nrow(expr) * 100
cols_to_keep <- which(missing_perc < 10)
expr_filtered <- expr[, cols_to_keep]

# Imputazione con mediana
expr_imputed <- apply(expr_filtered, 2, function(x) {
  x[is.na(x)] <- median(x, na.rm = TRUE)
  return(x)
})
expr_imputed <- as.data.frame(expr_imputed)
rownames(expr_imputed) <- rownames(expr_filtered)

# Normalizzazione (z-score)
df_scaled <- as.data.frame(scale(expr_imputed, center = TRUE, scale = TRUE))

# PCA
pca_res <- prcomp(df_scaled, center = FALSE, scale. = FALSE)
plot(pca_res, type = "l", main = "Scree plot PCA (post z-score)")

pca_df <- as.data.frame(pca_res$x)
pca_df$Group <- metadata$troubled_by_pain_or_discomfort_present_for_more_than_3_months

png("pca_endo.png")
ggplot(pca_df, aes(x = PC1, y = PC2, color = Group)) +
  geom_point(size = 2) +
  theme_bw(base_size = 14) +
  labs(title = "PCA on z-scored NPX (post-normalization, colored by pain status)",
       x = paste0("PC1 (", round(summary(pca_res)$importance[2, 1]*100, 1), "%)"),
       y = paste0("PC2 (", round(summary(pca_res)$importance[2, 2]*100, 1), "%)"))
dev.off()

###########################################
### LIMMA: confronto Yes vs No (senza covariate)
###########################################

# Filtrare solo Yes/No
metadata_chronic <- metadata %>%
  filter(troubled_by_pain_or_discomfort_present_for_more_than_3_months %in% c("No", "Yes"))

# Espressione corrispondente
expr_chronic <- expr[rownames(metadata_chronic), ]

# Definire fattore gruppo
metadata_chronic$condition <- factor(
  metadata_chronic$troubled_by_pain_or_discomfort_present_for_more_than_3_months,
  levels = c("No", "Yes"),
  labels = c("No_Pain", "Chronic_Pain")
)

# Design matrix senza covariate
design <- model.matrix(~0 + condition, data = metadata_chronic)
colnames(design) <- make.names(colnames(design))

# Contrast
contrast.matrix <- makeContrasts(conditionChronic_Pain - conditionNo_Pain, levels = design)

# LIMMA

fit <- lmFit(t(expr_chronic), design)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)

# Risultati
results_chronic <- topTable(fit2, sort.by = "P", n = Inf) %>%
  rownames_to_column(var = "protein") %>%
  mutate(FC = 2^(logFC))

# Filtrati per adj.P.Val < 0.05
filtered_df <- results_chronic %>%
  filter(!is.na(adj.P.Val) & adj.P.Val < 0.05)

# Volcano plot

volcano_plot <- ggplot(results_chronic, aes(x = logFC, y = -log10(P.Value))) +
  geom_point(aes(color = (adj.P.Val < 0.05 & abs(logFC) > 1))) +
  scale_color_manual(values = c("FALSE" = "grey", "TRUE" = "red")) +
  labs(x = "log2 fold change", y = "-log10 p-value") +
  ggtitle("Differential Protein Expression, Volcano Plot")

png("volcano_plot.png", width = 1080, height = 1080)
volcano_plot
dev.off()

# Salvataggio
write.csv(results_chronic, "Chronic_degs.csv", row.names = FALSE)
write.csv(filtered_df, "Chronic_degs_adjP0.05.csv", row.names = FALSE)





#######################################################################################
#######################################################################################
#######################################################################################
#######################################################################################

#### + COVARIATE 
#################################
#################################




library(janitor)
library(dplyr)
library(tidyr)
library(ggplot2)
library(limma)
library(reshape2)
library(readr)
library(magrittr)
library(tibble)

###########################################
### Import e preparazione dati
###########################################

# Import dati
endoicd <- read.delim("istance_3.csv", sep = ",", header = TRUE)
phenoicd <- read.delim("gender_pain_nocancer_all.csv", sep = ",", header = TRUE)

# Pulizia nomi colonne
endoicd <- clean_names(endoicd)
phenoicd <- clean_names(phenoicd)

# Metadata e espressione
metadata <- phenoicd
expr <- endoicd

# Associare ID come rownames
rownames(metadata) <- metadata$participant_id
metadata$participant_id <- NULL

rownames(expr) <- expr$participant_id
expr$participant_id <- NULL

# Tenere solo i pazienti comuni
common_ids <- intersect(rownames(metadata), rownames(expr))
metadata <- metadata[common_ids, ]
expr <- expr[common_ids, ]

###########################################
### Quality control: distribuzione per campione
###########################################

df_t <- t(expr)
df_long <- melt(df_t, varnames = c("Protein", "Sample"), value.name = "Expression")
df_long$Sample <- factor(df_long$Sample)

ggplot(df_long, aes(x = Sample, y = Expression)) +
  geom_boxplot(outlier.size = 0.5) +
  theme_bw(base_size = 14) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, size = 6)) +
  labs(title = "Distribution of samples (per sample boxplot)",
       x = "Sample",
       y = "Expression")

###########################################
### Normalizzazione e boxplot proteine
###########################################

df_scaled <- as.data.frame(scale(expr, center = TRUE, scale = TRUE))

png("QC_first_200_endo.png", width = 1080, height = 1080)
boxplot(df_scaled[, 1:min(200, ncol(df_scaled))],
        las = 2,
        main = "Distribution of the first 200 proteins (normalized)",
        ylab = "Z-scored Expression",
        outline = FALSE,
        cex.axis = 0.5)
dev.off()

###########################################
### PCA
###########################################

# Rimozione proteine con almeno 10% di NA
missing_perc <- colSums(is.na(expr)) / nrow(expr) * 100
cols_to_keep <- which(missing_perc < 10)
expr_filtered <- expr[, cols_to_keep]

# Imputazione con mediana
expr_imputed <- apply(expr_filtered, 2, function(x) {
  x[is.na(x)] <- median(x, na.rm = TRUE)
  return(x)
})
expr_imputed <- as.data.frame(expr_imputed)
rownames(expr_imputed) <- rownames(expr_filtered)

# Normalizzazione (z-score)
df_scaled <- as.data.frame(scale(expr_imputed, center = TRUE, scale = TRUE))

# PCA

pca_res <- prcomp(df_scaled, center = FALSE, scale. = FALSE)
plot(pca_res, type = "l", main = "Scree plot PCA (post z-score)")

pca_df <- as.data.frame(pca_res$x)
pca_df$Group <- metadata$troubled_by_pain_or_discomfort_present_for_more_than_3_months

png("pca_endo.png")
ggplot(pca_df, aes(x = PC1, y = PC2, color = Group)) +
  geom_point(size = 2) +
  theme_bw(base_size = 14) +
  labs(title = "PCA on z-scored NPX (post-normalization, colored by pain status)",
       x = paste0("PC1 (", round(summary(pca_res)$importance[2, 1]*100, 1), "%)"),
       y = paste0("PC2 (", round(summary(pca_res)$importance[2, 2]*100, 1), "%)"))
dev.off()

###########################################
### LIMMA: confronto Yes vs No con covariate
###########################################

# Filtrare solo Yes/No
metadata_chronic <- metadata %>%
  filter(troubled_by_pain_or_discomfort_present_for_more_than_3_months %in% c("No", "Yes"))

# Espressione corrispondente
expr_chronic <- expr[rownames(metadata_chronic), ]

# Definire fattore gruppo
metadata_chronic$condition <- factor(
  metadata_chronic$troubled_by_pain_or_discomfort_present_for_more_than_3_months,
  levels = c("No", "Yes"),
  labels = c("No_Pain", "Chronic_Pain")
)

# Covariate
metadata_chronic$age <- metadata_chronic$age_at_recruitment
metadata_chronic$sex <- factor(metadata_chronic$sex, levels = c("Male", "Female"))

# Design matrix
design <- model.matrix(~0 + condition + age + sex, data = metadata_chronic)
colnames(design) <- make.names(colnames(design))

# Contrast corretto
contrast.matrix <- makeContrasts(conditionChronic_Pain - conditionNo_Pain, levels = design)

# LIMMA

fit <- lmFit(t(expr_chronic), design)
fit2 <- contrasts.fit(fit, contrast.matrix)
fit2 <- eBayes(fit2)

# Risultati
results_chronic <- topTable(fit2, sort.by = "P", n = Inf) %>%
  rownames_to_column(var = "protein") %>%
  mutate(FC = 2^(logFC))

# Filtrati per adj.P.Val
filtered_df <- results_chronic %>%
  filter(!is.na(adj.P.Val) & adj.P.Val < 0.05)

# Volcano plot

volcano_plot <- ggplot(results_chronic, aes(x = logFC, y = -log10(P.Value))) +
  geom_point(aes(color = (adj.P.Val < 0.05 & abs(logFC) > 1))) +
  scale_color_manual(values = c("FALSE" = "grey", "TRUE" = "red")) +
  labs(x = "log2 fold change", y = "-log10 p-value") +
  ggtitle("Differential Protein Expression, Volcano Plot")

png("volcano_plot.png", width = 1080, height = 1080)
volcano_plot
dev.off()

# Salvataggio

write.csv(results_chronic, "Chronic_degs_cov.csv", row.names = FALSE)
write.csv(filtered_df, "Chronic_degs_cov_adjP0.05.csv", row.names = FALSE)


##################################################################################
##################################################################################
##################################################################################







